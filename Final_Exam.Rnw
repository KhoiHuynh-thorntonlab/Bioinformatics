%%KELLYS
%%======
%%Latex compiled great. One chunk (normalization) eval=FALSE.
%%heading looks nice.
%%Equation and its evaluation look nice. Answer is correct.
%%Write-up for the ChIP-Seq section is brilliant.
%%ChIP-Seq analysis appears to have been done correctly.
%%Nice QC and volcano plot.
%%Your CMap results concur with Blondik's. Both of you were looking for anti-correlated.
%%The multiple alignment and phylogenetics section was extremely well done and very well written up.
%%Your write-ups were among the best in the class. Well-edited prose.
%%Baffled why you kept the normalization section eval=FALSE ? The code looks fine.
%%Highest grade in class. The only A in the class for this exam.
%%GRADE=A
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass{article}
\usepackage[sc]{mathpazo} %This changes the font away from Computer Modern
\usepackage[T1]{fontenc}
\usepackage{geometry} %Sets page dimensions
\geometry{verbose,tmargin=2.5cm,bmargin=2.5cm,lmargin=2.5cm,rmargin=2.5cm}
\setcounter{secnumdepth}{2}
\setcounter{tocdepth}{2}
%\usepackage{array,booktabs}
\usepackage{cite} %Might be necc for bibtex
\usepackage[labelfont=bf]{caption} % Necessary for bold-Figure titles.
\usepackage[unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=true,bookmarksopen=true,bookmarksopenlevel=2,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=false]
 {hyperref}
\definecolor{darkblue}{rgb}{0.0,0.0,0.3}
\hypersetup{colorlinks,breaklinks,
            linkcolor=darkblue,urlcolor=darkblue,
            anchorcolor=darkblue,citecolor=darkblue}
%\hypersetup{pdfstartview={XYZ null null 1}} %this is knitr default
\usepackage{breakurl}
\usepackage{etoolbox} %
\usepackage{forloop}
\usepackage{tikz} %necc for latex foreach loops
\usepackage{subcaption} %for subfigures
\usepackage{amsmath}%required for nice equations
\usepackage{graphicx}%this package comes in handy for including graphics
\usepackage{url} %for typesetting pretty URLs
%\usepackage{inconsolata} % Made R code look tidier in early versions of knitr
\begin{document}% there are some commands in latex you can mess with; never mess with this one
% Also, never mess with the following chunk unless you think you know what you're doing:
<<setup, include=FALSE, cache=FALSE>>=
# this is equivalent to \SweaveOpts{...}
opts_chunk$set(fig.path='figure/latex-', fig.align='center', fig.show='hold')
options(replace.assign=TRUE,width=90)
require(highlight)
@ 

 
\title{Final Exam}

\author{%this section includes affiliations
Stephen Kelly\,$^{1}$, %Your name
% John Q. Public\,$^{2}$,  %Your collaborator's name
 and Dr. Mark Holland\,$^{1,*}$ 
\\
\\
%Affiliations:
\footnotesize $^{1}$Department of Biological Sciences, Salisbury University,\\
\footnotesize Henson Science Hall 230H, Salisbury, MD 21801, USA\\
\\
\footnotesize $^{*}$To whom correspondence should be addressed. Tel: 410-011-2358; Fax: 410-314-1592;\\
\footnotesize Email: \texttt{sk81638@gulls.salisbury.edu,}
} 
\date{December 4, 2013}

\maketitle

\section{Formula Programming}
In this section we will show how to insert an equation into a \LaTeX{} document. One of the strengths of \LaTeX{} is its ability to display attractively formatted mathematics equations. For example, this is the 'Student's t-test':
\begin{equation}
t = \frac{\bar{X}_1 - \bar{X}_2}{s_{X_1 X_2} \cdot \sqrt{\frac{1}{n_1} + \frac{1}{n_2}}}
\end{equation}
Next, we will demonstrate how to use the R\cite{R} programming language, embedded in our \LaTeX{} document, to evaluate an equation. We will evaluate the above equation in R\cite{R}.
<<maths,eval=TRUE>>=
X1<-27.712
X2<-29.658
sX1X2<-0.1274
n1<-5
n2<-5

(X1-X2)/(sX1X2*(sqrt((1/n1)+(1/n2)))) 
@
To perform this simple calculation, we created objects with our values of interest, and passed them through the equation to return an answer. As you can see, R\cite{R} and \LaTeX{} work together beautifully to perform basic math functions. 
\section{Systems Bio Workflow}
%%%%%%%%%%%%%%%%
\begin{abstract}
In this section, we will analyze data from Soule et. al.\cite{soule_1973} regarding a study about human breast carcinoma. In this study, cell line MCF-7 was isolated from a patient with breast cancer. By passing code through the bash\cite{bash} console from \LaTeX{}, we will process raw sequence data obtained from this study, analyze the reads, and annotate any peaks that we find. 
% http://jnci.oxfordjournals.org/content/51/5/1409.abstract full document behind paywall!!
\end{abstract}
%%%%%%%%%%%%%%%%
\subsection{ChIP-Seq}
<<fastqc,eval=TRUE,engine='bash'>>=
cd /home/kellys/Final_Exam/
  mkdir Quality_Control
cd /opt/Genomics490/Final_Exam/ChIP-Seq_Data/
for file in *.fastq
do
  fastqc --outdir /home/kellys/Final_Exam/Quality_Control/ \
/opt/Genomics490/Final_Exam/ChIP-Seq_Data/$file
  echo "processed \"$file\""
bowtie -q --phred33-quals --sam \
/opt/iGenomes/Homo_sapiens/Homo_sapiens/UCSC/hg19/Sequence/BowtieIndex/genome \
/opt/Genomics490/Final_Exam/ChIP-Seq_Data/$file \
/home/kellys/Final_Exam/$file.sam
echo "Done bowtie \"$file\""
done
@
In this section, we use the FastQC\cite{fastqc} tool to perform quality control analysis on all of our ChIP-Seq sequence samples. It should be noted that all samples were of good quality, as viewed in the FastQC output files which were not included in this document. If some of the samples had failed FastQC or had several poor quality sequences, we could have removed them from further analysis  or trimmed them back to only include the sequence portions of acceptable quality. Next, we pass the samples through Bowtie\cite{bowtie} to align the reads. This code is made portable through the use of a 'for loop', which will automatically detect .fastq files in our ChIP-Seq directory and pass them through FastQC and Bowtie. The .SAM files created by Bowtie will be used in the next step.
<<tagdir,eval=TRUE,engine='bash'>>=
cd /home/kellys/Final_Exam/
mkdir /home/kellys/Final_Exam/Tag_Dir/
for file in *.sam 
do 
mkdir \
/home/kellys/Final_Exam/Tag_Dir/$file
echo "Tagging \"$file\""
makeTagDirectory /home/kellys/Final_Exam/Tag_Dir/$file \
-format sam -unique -genome hg19 \
/home/kellys/Final_Exam/$file
echo "done tagging \"$file\"" 
done
@
Here we use Homer\cite{homer} to create a Tag directory, which will contain information about the experiment analysis for use in the immediate future. 
<<callpeaks,eval=TRUE,engine='bash'>>=
cd /home/kellys/Final_Exam/Tag_Dir/
mkdir Control
mv SRR577916.fastq.sam/ Control/
for file in *.sam
  do
echo "Finding peaks for \"$file\" "
findPeaks /home/kellys/Final_Exam/Tag_Dir/"$file" \
-style factor -center -o auto -i /home/kellys/Final_Exam/Tag_Dir/Control/SRR577916.fastq.sam/
echo "tagged \"$file\"" 
  done
@
In this section, we use the findPeaks\cite{findpeaks} command to identify areas of enrichment in the experimental samples.
<<annotatepeaks,eval=TRUE,engine='bash'>>=
cd /home/kellys/Final_Exam/Tag_Dir/
for file in *.sam 
do 
echo "Annotating peaks for \"$file\" "
annotatePeaks.pl /home/kellys/Final_Exam/Tag_Dir/$file/peaks.txt hg19 > /home/kellys/Final_Exam/Tag_Dir/$file/annotated_peaks.txt 
echo "Done annotating peaks for \"$file\"" 
done
@
And finally, in this chunk, we have used the annotatePeaks\cite{annotatepeaks} command to label the peaks we found in our data! That is the conclusion of the ChIP-Seq analysis for this section. We will be referring to the annotated peak files we created here later in our analysis.  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Microarray}
% http://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSM791064 
% http://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE31912 this is where the sample information is located
In this section, we will analyze Microarray data generated from RNA extracts of treated and untreated MCF7 cells\cite{geo}, showing gene expression information. During their testing, researchers knocked down 78 different molecules through RNAi. For our purposes, we will examine 3 control samples and 1 siRNA knockdown sample of transcription factor JunD. 
<<loadreqs,eval=TRUE>>=
suppressPackageStartupMessages(require(affy))
suppressPackageStartupMessages(require(plyr))
@
<<loadCEL, eval=TRUE>>= 
celdir<-c('/opt//Genomics490//Final_Exam//Microarray_Data')
dat<-ReadAffy(celfile.path=celdir)
save(dat,file='dat_AffyBatch.Robj')
AA<-rep.int('Control_',times=length((sampleNames(dat)))-1)
BB<-seq(1:length(AA))
ArrayNames<-c('JunD_Silenced',paste(AA,BB,sep=''))
sampleNames(dat)<-ArrayNames 
pData(dat)<-within((pData(dat)),Type<-c('Test','Control','Control','Control'))
save(dat,file='dat_AffyBatch.Robj') 
#load('/home/kellys/Exam_2_usethis/dat_AffyBatch.Robj') 
@
In this chunk, we have loaded the CEL files from the study in the 'dat' object for processing, and we have added a column to the phenotype data that describes each sample as a test or a control. We used the Affy\cite{affy} and Plyr\cite{plyr} packages for this purpose.
<<xtable2,results='asis',eval=TRUE>>=
suppressPackageStartupMessages(require(xtable)) #dat[rows,coluimns]
table<-pData(dat)
print(xtable(table,
       caption='Microarray Sample information',
       include.rownames=T)) #generate a nice little table to display all the info
@
Here we have generated a nice table using the XTable\cite{xtable} package, displaying information about the microarray samples we will be using. 
\subsection{Quality Control}
<<QCreq,eval=TRUE>>=
suppressPackageStartupMessages(require(affyPLM))
@

<<QC1,eval=TRUE>>=
RNADegpastefile<-0 #the number of RNADeg png's written out
RLEpastefile<-0 #the number of RLE png's written out
NUSEpastefile<-0 #the number of NUSE png's written out
Arraypastefile<-0 #does not actually do anything here, works better to declare it later
section<-4 #Some number that is divisible by 4 (the number of arrays); size of processing groups
iteration<-1
Count1<-0
Count2<-0
i<-1
@

<<qc2,eval=TRUE>>=
for (i in seq(from = 1, to = length(sampleNames(dat)), by=section)) {
    print(paste("Iteration #",iteration,sep=' '))

  Count1<-i
  Count2<-Count1+(section-1)
  print(paste("Arrays Processed",Count1,Count2,sep=':'))
  QC_Batch<-dat[,c(Count1:Count2)]
print(sampleNames(QC_Batch))
    
       Pset<-fitPLM(QC_Batch)


  Colors<-rainbow(n=length(sampleNames(QC_Batch)))
  deg<-AffyRNAdeg(QC_Batch)
    
    #Begin RNA Deg pastefile
    
  pngfile=paste('RNA_Deg_Plot',iteration,'.png', sep='')
  png(file=pngfile,width=700,height=700,res=80)
  RNAdeg<-plotAffyRNAdeg(deg,cols=Colors)
  legend(legend=sampleNames(QC_Batch),
       x='topleft',
       lty=1,
       cex=0.9,
       col=Colors)
  dev.off()
    
    RNADegpastefile<-RNADegpastefile+1

  print(summaryAffyRNAdeg(deg) ) 
    
 #End RNA degradation pastefile
    
    
   #Begin RLE pastefile
    
  pngfile=paste('RLE',iteration,'.png', sep='')
  png(file=pngfile,width=700,height=700,res=80)
  RLE(Pset,main=paste('RLE for JunD-silenced Gene expression samples',Count1,Count2,sep=':'),col=Colors,las=2)
  dev.off()
    
    RLEpastefile<-RLEpastefile+1
    
#End RLE pastefile
    
    #Begin NUSE pastefile
    
  pngfile=paste('NUSE',iteration,'.png', sep='')
  png(file=pngfile,width=700,height=700,res=80)
  NUSE(Pset,main=paste('NUSE for JunD-silenced Gene expression samples',Count1,Count2,sep=':'),col=Colors,las=2)
  dev.off()
    
    NUSEpastefile<-NUSEpastefile+1
    
#End NUSE pastefile
    
  iteration<-iteration+1
  print(paste("Going to Iteration #",iteration,sep=''))
}

  # Write out 4 pseudoimages.

  QC_Batch<-dat
   ArrayNames<-sampleNames(QC_Batch)
 Pset<-fitPLM(QC_Batch)
   for (i in 1:length(ArrayNames)) 
     {
     pngfile=paste(i,".png", sep='')
     png(file=pngfile,width=700,height=700,res=80)
     image(Pset,which=i,type='resids',useRaster=F,add.legend=T)
    dev.off()
     
     Arraypastefile<-Arraypastefile+1
   }
@
In these sections, which have been broken up for debugging purposes, the AffyPLM\cite{affyPLM} package was used to help run quality control on the arrays. Counters and iterators were created and used to keep track of the number of .PNG image files that were written out by the for-loops used in these and future sections. Images generated this way will be displayed in the sections below to allow for easy data analysis. 
\subsection{RNA Degradation}
Next, we will examine the RNA degradation of the microarrays. Since we know that RNA degrades in the 5' to 3' direction, we can create linear models to illustrate the amount of RNA degradation across the gene sets. Again, AffyPLM\cite{affyPLM} was used to make these plots in the previous section. 
When large amounts of samples must be processed, a Latex 'for loop' may be used; we are only studying 4 microarrays here, so the loop is not necessary. For RNA samples, a slope of >1.7 indicates a large amount of  degradation. The majority of these arrays show slopes of much greater than 1.7, therefore we can conclude that there was a large amount of RNA degradation on these arrays. However, the RNA degradation was rather consistent across arrays, and we have a small number of samples, so we will not exclude data based on this. Otherwise, we would have no samples left to analyze.
% \begin{figure}
%         \centering
%         \begin{subfigure}[b]{0.3\textwidth}
%                 \centering
%                 \includegraphics[width=\textwidth]{RNA_Deg_Plot1}
%                 \caption{}
%                 \label{fig:Cont8}
%         \end{subfigure}%
%                 ~ %
%         
%         \caption{RNA Degredation Plot}
%         \label{fig:cels}
% \end{figure} 
%^^This is a sample subfigure template!

\begin{figure}
    \centering
    \includegraphics[width=0.8\textwidth]{RNA_Deg_Plot1}
    \caption{RNA Degradation Plot}
    \label{}
\end{figure}

%%%%%
\subsection{Relative Linear Expression}
In this section, we will examine the Relative Log Expression (RLE), which shows the expression values for each array as compared to the median expression values for all instances of the probeset on all arrays. Due to the nature of the analysis method, differences in data here can be more subtle. No arrays failed this test. 

\begin{figure}
    \centering
    \includegraphics[width=0.8\textwidth]{RLE1}
    \caption{RLE plot}
    \label{}
\end{figure}

%%%%%
\subsection{NUSE}
NUSE stands for Normalized Unscaled Standard Errors. In these plots, data from each gene is normalized based on the entire array's data so that values are comparable. A good NUSE graph has the data box near the center value of one. All arrays passed the NUSE test. 

\begin{figure}
    \centering
    \includegraphics[width=0.8\textwidth]{NUSE1}
    \caption{NUSE plot}
    \label{}
\end{figure}
%%%%%%%%%%
\subsection{Array Image Analysis and Bad Arrays}
We shall take a look at psuedoimages of the arrays in the set! Remember, a good array shows an even distribution of random hybridization patterns, free from defects.
Bad arrays must be removed from the data set, or they will skew the results. Arrays are being evaluated based on the RNA Degradation plots, the RLE plots, and the NUSE plots, along with visual hybridization analysis. Visually, the arrays must be free of defects, and must show an evenly distributed random hybridization.
Arrays that fail any of these analyses will be removed from the set.
In order to remove bad arrays, a vector is created holding the numbers of each failed array. Then, a new data series is created to hold all failed arrays, while the failed arrays are found within the original data set and removed. The object holding the bad arrays is later used to write out image files of the bad arrays. 
In data sets that include many arrays, a Latex for loop can be used to display all arrays quickly for easy viewing. However, since we only have 4 arrays, we can skip that step and instead directly call each figure. 

\begin{figure}
    \centering
    \includegraphics[width=0.8\textwidth]{1}
    \caption{Pseudo-image of experimental JunD silenced microarray}
    \label{}
\end{figure}

\begin{figure}
        \centering
        \begin{subfigure}[b]{0.3\textwidth}
                \centering
                \includegraphics[width=\textwidth]{2}
                \caption{}
                \label{fig:Cont8}
        \end{subfigure}%
                ~ %
        \begin{subfigure}[b]{0.3\textwidth}
                \centering
                \includegraphics[width=\textwidth]{3}
                \caption{}
                \label{fig:Cont8}
        \end{subfigure}%
                ~ %
         \begin{subfigure}[b]{0.3\textwidth}
                \centering
                \includegraphics[width=\textwidth]{4}
                \caption{}
                \label{fig:Cont8}
        \end{subfigure}%
                ~ %
       
        \caption{Pseudo-images of control microarray}
        \label{fig:cels}
\end{figure}

We can see that the JunD silenced microarray shows some hybridization defects near the center of the array. However, due to the small number of arrays included in this sample, and the fact that this is our only test array, we will refrain from excluding it based on this. It should also be noted that the RLE and NUSE plots looked pretty good for all of these arrays. All arrays will be included for further analysis.

\subsection{Normalization}
Now we must normalize the data so the various arrays are comparable to each other. 
<<normalization,eval=FALSE>>=
eset<-expresso(dat,
               bgcorrect.method='rma',
               normalize.method='quantiles',
               summary.method='medianpolish',
               pmcorrect.method='pmonly')
save(eset,file="eset.Robj")
eset_unnormalized<-expresso(dat,
               bg.correct='FALSE',
               normalize='FALSE',
               summary.method='medianpolish',
               pmcorrect.method='pmonly')
save(eset_unnormalized,file="eset_unnorm.Robj")
@
In this section, we have created expression set data, known as an eset, by using the expresso command, included in the Affy\cite{affy} package. We have created expression sets for the normalized and unnormalized data, and saved both copies to files on the local machine for faster loading during debugging efforts. 
<<esetloads,eval=TRUE>>=
load(file='/home/kellys/Final_Exam/eset_unnorm.Robj')
load(file='/home/kellys/Final_Exam/eset.Robj')
@
<<eset_sets,eval=TRUE>>=
normalized.data<-exprs(eset)
unnormalized.data<-exprs(eset_unnormalized)
@

\subsection{Check Normalization}
The array data was previously normalized to make proper sense out of it, and to be able to compare the results to each other. Now, we must check the normalized data against the unnormalized data. 
<<boxplots,eval=TRUE>>=
iterator<-4 #number of arrays 
Colors<-c('black')
for (i in seq(from=1,to=length(colnames(normalized.data)),by=iterator)) {
  Count1<-i
  Count2<-i+(iterator-1)
  print(paste(Count1,Count2,sep=":"))
  NormPlot<-normalized.data[,Count1:Count2]
  UnnormPlot<-unnormalized.data[,Count1:Count2]
  pngfile<-paste('NormUnnorm',Count1,Count2,'Boxplot',".png", sep='-')
  png(file=pngfile,width=700,height=700,res=80)
  par(mfrow=c(2,1))
  boxplot(data.frame(NormPlot),
                     col='green',
                     main=paste('Normalized Microarray Data',Count1,Count2,sep=':'),
                     las=2,
                     border=rev(Colors))
  boxplot(data.frame(UnnormPlot),
                     col='purple',
                     main=paste('Unnormalized Microarray Data',Count1,Count2,sep=':'),
                     las=2,
                     border=rev(Colors))
  dev.off()
}
@
In this step, we use the normalized and unnormalized data to write out images of boxplots.
The normalized and unnormalized data plots will be displayed below, for comparison. These were created by writing the plots to .PNG image files, then embedding them in the document as figures. From these plots, you can tell that the normalization was a success.  

 \begin{figure}
    \centering
    \includegraphics[width=0.8\textwidth]{NormUnnorm-1-4-Boxplot-.png}
    \caption{Normalization plots}
    \label{}
\end{figure}

\subsection{Annotation}
Now we must annotate the data set in order to describe the chromosomal and functional aspects of each gene in the study.
<<geneReqs,eval=TRUE>>=
suppressPackageStartupMessages(require(AnnotationDbi))
suppressPackageStartupMessages(require(genefilter))
suppressPackageStartupMessages(require(hgu133plus2.db)) #eset@annotation:hgu133plus2
@

<<removeNonGenes,eval=TRUE>>=
filt_eset<-nsFilter(eset,
                     require.entrez=T,
                     remove.dupEntrez=T,
                     feature.exclude='^AFFY',
                     var.filter=F)
length(featureNames(eset))
length(featureNames(filt_eset))
eset<-filt_eset$eset
@
In these steps, we use the AnnotationDbi\cite{AnnotationDbi} and Genefilter\cite{genefilter} R packages to create a filter that will remove non-genes from the array data sets. Information is drawn from the HGU133plus2\cite{hgu133plus2} database. 
\subsection{Annotate Features}
<<annotate,eval=TRUE>>=
suppressPackageStartupMessages(require(annotate))
suppressPackageStartupMessages(require(R2HTML))
TranscriptID<-featureNames(eset)
GeneSymbol<-getSYMBOL(TranscriptID,'hgu133plus2.db')
GeneName<-as.character(lookUp(TranscriptID,'hgu133plus2.db','GENENAME'))
EntrezID<-as.character(lookUp(TranscriptID,'hgu133plus2.db','ENTREZID'))
EntrezID<-ifelse(EntrezID=="NA",
                 NA,
                 paste("<a href='http://www.ncbi.nlm.nih.gov/gene/",EntrezID, "'>", EntrezID, "</a>", sep=""))
Ensembl <-as.character(lookUp(TranscriptID,'hgu133plus2.db','ENSEMBL'))
Ensembl <-ifelse(Ensembl=="NA",
                 NA,
                 paste("<a href='http://useast.ensembl.org/Homo_sapiens/Gene/Summary?g=",Ensembl, "'>", Ensembl, "</a>", sep=""))
tmp<-data.frame(TranscriptID=TranscriptID,
                GeneSymbol=GeneSymbol,
                EntrezID=EntrezID,
                Ensembl=Ensembl,
                GeneName=GeneName,
                stringAsFactors=F)
tmp[tmp=='NA']<-NA
fData(eset)<-tmp
save(eset,file="eset_annotated.Robj")
@
Here, we have removed non-genes from the data set, and created an HTML table that includes all the annotated information for the genes. We used the Annotate\cite{annotate} and R2HTML\cite{R2HTML} packages for this. This table provides is with hyperlinks to information about each gene in the Ensembl and Entrez databases. 

\subsection{Differential Expression}
In order to understand the changes in gene expression during the experiment, we need to first create some hypotheses based on the samples and variables included in the study. Our hypotheses will be as follows:
\begin{enumerate}
\item There will be a difference in expression between JunD silenced sample and the control samples
\end{enumerate}
Now that we have a hypothesis, we can begin to test it and find out if there really was a difference in gene expression between these groups. 
<<limma,eval=TRUE>>=
suppressPackageStartupMessages(require(limma))
suppressPackageStartupMessages(require(affy))
suppressPackageStartupMessages(require(R2HTML))
suppressPackageStartupMessages(require(gdata))
suppressPackageStartupMessages(require(plyr))
suppressPackageStartupMessages(require(biomaRt))
f1<-factor(pData(eset)[['Type']])
design<-model.matrix(~0+f1)
fit<-lmFit(eset,design)
contrast.matrix<-makeContrasts(hyp1=f1Control-f1Test,
                               levels=design)
fit2<-contrasts.fit(fit,contrast.matrix)
fit2<-eBayes(fit2)
outTable<-topTable(fit2,coef=1,number=5000,adjust='BH',sort.by="p") 
outTable<-subset(outTable,subset=(P.Value<0.05)) #using P values if Adj. P Val. are all >0.5
nrow(outTable)
NumberofSignficantGenes<-nrow(outTable) #477

# to look at which genes have the most changed, use webgestalt: http://bioinfo.vanderbilt.edu/webgestalt/option.php

Webgestalt<-as.character(outTable[['TranscriptID']]) 
write(Webgestalt,file='WebGestalt',sep='\n') 
HTML(outTable,'JunD_Silence.html',append=F)
pngfile=paste('Volcanoplot','.png', sep='')
  png(file=pngfile,width=800,height=800,res=80)
  volcanoplot(fit2,coef=1,highlight=NumberofSignficantGenes,names=fit2$genes$GeneSymbol)
  dev.off()
GenesUP<-subset(outTable,subset=(logFC>0))
GenesDN<-subset(outTable,subset=(logFC<0))
@
In this section we used Limma\cite{limma} and Affy\cite{affy} along with R2HTML\cite{R2HTML} and gData\cite{gdata}. We created a design matrix and contrast matrix, then ran the gene expression data through tests in order to output a table of significant genes related to hypothesis number 1. In this  resulting table, we included only genes whose raw P value was less than 0.05 since the adjusted P values for this set were all greater than 0.5. This can be analyzed with WebGestalt\cite{WebGestalt} by exporting a list of the transcript IDs, and then running a KEGG analysis on them from the WebGestalt website. A .TSV file with information on related biological pathways can then be downloaded from WebGestalt and uploaded to our server. A volcano plot was also made to illustrate the most significant genes, of which the top results include FUT9, HIPK2, and FOXA1. Significance here has been determined by P-value, instead of adjusted P-value, due to the issue of multiple testing and false discovery rates. Since thousands of genes are being tested in each sample, the chances of false positives appearing in the sample is very high; even if there is only a very small chance of a false positive appearing, this likelihood is compounded by the high sample size. 

\begin{figure}
    \centering
    \includegraphics[width=0.8\textwidth]{Volcanoplot}
    \caption{Volcano plot of significantly changed genes}
    \label{}
\end{figure}

<<xtablegenesUP,results='asis',eval=TRUE>>=
suppressPackageStartupMessages(require(xtable)) 
print(xtable(head(subset(GenesUP,select=c('TranscriptID','GeneSymbol','logFC','P.Value'))),
       caption='Upregulated genes',
       include.rownames=T))
@

<<xtablegenesDN,results='asis',eval=TRUE>>=
suppressPackageStartupMessages(require(xtable)) 
print(xtable(head(subset(GenesDN,select=c('TranscriptID','GeneSymbol','logFC','P.Value'))),
       caption='Downregulated genes',
       include.rownames=T))
@
\subsection{Integrated Workflow}
In the following sections, we will combine the data generated from the ChIP-Seq analysis and the microarray analysis in order to find more information about what genes were changed by the JunD silencing experiment. 
\begin{enumerate}
\item First we must import the Annotated Peaks files.
<<importpeaks,eval=TRUE>>=
peaks1<-read.delim('/home/kellys/Final_Exam/Tag_Dir/SRR577997.fastq.sam/annotated_peaks.txt')
peaks2<-read.delim('/home/kellys/Final_Exam/Tag_Dir/SRR577998.fastq.sam/annotated_peaks.txt')
@
\item How many genes bound in the samples?
<<uniquegenes,eval=TRUE>>=
length(unique(peaks1[,'Gene.Name']))#The number of unique genes bound in SRR577997; peaks1
length(unique(peaks2[,'Gene.Name']))#The number of unique genes bound in SRR577998; peaks2
@
\item Next we will create a pairwise Venn Diagram showing how many genes were bound in both ChIP-Seq samples.
<<pairwise,eval=TRUE>>= 
suppressPackageStartupMessages(require(VennDiagram))


pngfile=paste('Venn','.png', sep='')
  png(file=pngfile,width=800,height=800,res=80)
venn.plot<-draw.pairwise.venn(area1=length(unique(peaks1[['Gene.Name']])),
                              area2=length(unique(peaks2[['Gene.Name']])),
                              cross.area=length(intersect((unique(peaks2[['Gene.Name']])),(unique(peaks1[['Gene.Name']])))),
                              category=c('SRR577997','SRR577998'),
                              fill=c('red','blue'),
                              alpha=c(0.3,0.3), #transparency
                              cex=c(2,2,2), #text size
                              cat.cex=c(2,2)
                              ) 
dev.off()
@
\begin{figure}
    \centering
    \includegraphics[width=0.8\textwidth]{Venn}
    \caption{Venn Diagram of bound genes between samples}
    \label{}
\end{figure}

5055 genes in SRR577997 are also in SRR577998. This is not surprising because these samples were replicates, so they should have a lot of genes in common.  

\item What are the names of the genes bound in both JunD data sets? Lets just look at first 25 genes.
<<genesbound,eval=TRUE>>=
intersect((unique(peaks2[['Gene.Name']])),(unique(peaks1[['Gene.Name']])))[1:25]
@
\item Now we will create an R object to hold the bound genes.
<<genesboundset,eval=TRUE>>=
genes_bound<-intersect((unique(peaks2[['Gene.Name']])),(unique(peaks1[['Gene.Name']])))
@
\item How many genes are up-regulated in both microarray and ChIP-Seq samples?
<<bothgenesUP,eval=TRUE>>=
length(intersect(genes_bound,unique(GenesUP[['GeneSymbol']]))) #number of genes in common!
both_genesUP<-intersect(genes_bound,unique(GenesUP[['GeneSymbol']]))
@
This shows the length of the intersection between the bound genes in the ChIP-Seq and up-regulated genes in the microarray, then saves the results into an object. 
\item How many genes are down-regulated in both microarray and Chip-Seq samples?
<<bothgenesDN,eval=TRUE>>=
length(intersect(genes_bound,unique(GenesDN[['GeneSymbol']]))) #number of genes in common!
both_genesDN<-intersect(genes_bound,unique(GenesDN[['GeneSymbol']]))
@
This shows the length of the intersection between the bound genes in the ChIP-Seq and down-regulated genes in the microarray, then saves the results into an object. 
\item Here we will create a connectivity map using Limma\cite{limma}, BiomaRt\cite{biomaRt}, Plyr\cite{plyr}, and gData\cite{gdata}.
<<connmap,eval=TRUE>>=
suppressPackageStartupMessages(require(limma))
suppressPackageStartupMessages(require(gdata))
suppressPackageStartupMessages(require(plyr))
suppressPackageStartupMessages(require(biomaRt))
ensembl<-useMart("ensembl")
ensembl<-useDataset("hsapiens_gene_ensembl",mart=ensembl)
GenesUPconverted<-as.character(getBM(attributes=c('affy_hg_u133a'),     
                                     filters='hgnc_symbol',             
                                     values=both_genesUP,               
                                     mart=ensembl))
GenesDNconverted<-as.character(getBM(attributes=c('affy_hg_u133a'),     
                                     filters='hgnc_symbol',             
                                     values=both_genesDN,               
                                     mart=ensembl))

write(GenesUPconverted,file='YourQuery-UP.grp',append=F)
write(GenesDNconverted,file='YourQuery-DN.grp',append=F)
CMap<-read.xls(xls='permutedResults100525.xls')
@
We can use the Connectivity map results to determine what drugs produce changes in gene expression that are correlated with JunD silencing - producing similar gene expression patterns - or are anti-correlated with JunD silencing - producing opposite expression patterns. 

As elucidated by Mehraein-Ghomi et. al \cite{JunD_androgen}, JunD upregulation is vital in the creation of androgen-induced Reactive Oxygen Species(ROS) that can lead to cancer progression in prostate carcinomas. 

However, Gerald et al.\cite{JunD_Tumor} states that in immortalized fibroblast lines (3T3 mouse cells), JunD over-expression decreases cell proliferation while silencing the junD gene increases proliferation, and that over-expression of JunD leads to reduced angiogenesis in tumor cells and "protects cells from oxidative stress by limiting ROS production".  

Meanwhile, Caffarel et. al.\cite{JunD_THC} found that Delta(9)-tetrahydrocannabinol activated JunD up-regulation lead to a decrease of proliferation of breast cancer cells. 

Based on these seemingly conflicting reports on the effects of JunD on cancer cells, suggestions as to the modulation of JunD for the purpose of cancer treatment may require the consideration of which type of cancer the patient is displaying. As our current samples came from breast cancer carcinomas, we will follow the insights of Caffarel et. al.\cite{JunD_THC} and seek to up-regulate JunD for the purposes of this exercise. With this in mind, we must consider that our gene expression samples have been derived from JunD-silenced human breast carcinoma cells. In order to suggest a potential treatment, we should look for drugs that produce the opposite effect of JunD silencing in regards to gene expression; therefore, we should seek out the most anti-correlated drugs that we can find in our Connectivity Map. This will be represented by drugs that have highly negative connectivity and enrichment scores, ranked by P-value. 

In this section, we have used Limma\cite{limma}, BiomaRt\cite{biomaRt}, Plyr\cite{plyr}, and gData\cite{gdata} to create lists of genes that have been up-regulated and down-regulated in the JunD-silenced sample. These files were then written out as .GRP files, which were passed to the Connectivity Map\cite{NCBI} website for analysis. The resulting Excel spreadsheet with drug results was uploaded and called by the read.xls command. 

\item Next we will make an xtable\cite{xtable} out of the connectivity map data, showing only the interesting drugs.
<<xtable3,results='asis',eval=TRUE>>=
suppressPackageStartupMessages(require(xtable)) 

print(xtable(CMap[1:4,],
       caption='Top 4 drugs of interest',
       include.rownames=T))
@
As mentioned in the previous section, we are examining the Connectivity Map to find negatively enriched drugs with the best P values. As you can tell from the above table, 2 of the top 4 drugs based on lowest P-value have negative enrichment values. These drugs are tretinoin and oxaprozin. Tretinoin is a drug commonly used topically for the treatment of acne\cite{tretinoin}, while oxaprozin is a non-steroidal anti-inflammatory drug commonly used to treat arthritis in elderly patients\cite{oxaprozin}. 

\end{enumerate}

\subsection{Genes Bound and Unbound} 
The expression of some genes are changed by JunD silencing but are not bound by JunD in the ChIP-Seq. At the same time, some genes are bound by JunD but do not show any and change in gene expression when JunD is silenced. This could be due to the process through which transcription factors like JunD function. 
It is possible for a transcription factor to change the expression of a gene that it does not bind to by instead binding to and changing the expression of another gene upstream of the gene of interest, which in turn affects expression of the gene of interest. 
Similarly, it is possible that JunD could bind to a gene but not change expression of the gene through the same mechanism, where JunD is downstream of another required gene whose expression is being blocked by an alternative pathway, or whose gene product is blocking the expression of the gene bound by JunD, regardless of JunD's binding.

\section{Multiple Alignment and Phylogenetics}
\begin{abstract}
In order to analyze the potential evolutionary relationship between extinct and extant proboscideans, we will query the mitochondrial genome of 6 species of mammoth, mastodon, and elephant, along with 2 species of out groups. The COX1 gene will be used to create a possible phylogeny for these species. This gene has been chosen based on its conservation among animal species. 
\end{abstract}
In this section, we will be using the Genomes\cite{genomes} package to analyze the COX1 gene sequence of several species.

<<fetch,eval=TRUE>>=
suppressPackageStartupMessages(require(genomes))
Sys.setenv(email='name@EMAIL.com')#blank email for privacy protection : NCBI
#NucSearch<-esearch('genome complete mitochondrion Loxodonta cyclotis','nuccore') #can't view an EntrezHistory, need to convert to a data frame
#y<-esummary(NucSearch)
#^^^this code was used to search for the Caption IDs of each species
Latin_Name<-c('Mammut americanum','Loxodonta africana','Elephas maximus','Mammuthus columbi','Mammuthus primigenius','Loxodonta cyclotis','Procavia capensis','Trichechus manatus')
Common_Name<-c('American mastodon','African Elephant','Asian elephant','Columbian mammoth','Woolly mammoth','African forest elephant','Rock hyrax','West Indian manatee')
Accession_ID<-c('NC_009574','DQ316069','EF588275','JF912199','NC_007596','JN673264','NC_004919','NC_010302')
Animal_Data<-data.frame(Latin_Name,Common_Name,Accession_ID)
system('if [ -e "Fetch.fasta" ]
then
  echo "Removing existing Fetch.fasta"
  rm Fetch.fasta
fi')
for (i in (seq(from= 1,to= nrow(Animal_Data),by=1))){  
FASTA_names<-c('>American_mastodon','>African_Elephant','>Asian_elephant','>Columbian_mammoth','>Woolly_mammoth','>African_forest_elephant','>Rock_hyrax','>West_Indian_manatee')
Fetch<-(efetch(Animal_Data[[i,3]],'nuccore','fasta_cds_na')) 
COX1_Location<-grep('COX1',Fetch)
ID_Locations<-grep('>',Fetch)
write((paste((FASTA_names[i]),sep="\n",collapse='')),file='Fetch.fasta',ncolumns=1,append=T)
write(paste((Fetch[(COX1_Location+1):((ID_Locations[grep(COX1_Location,ID_Locations)+1])-1)]),"",sep='\n',collapse=''),file='Fetch.fasta',ncolumns=1,append=T)
}
@
Here we have used the Genomes package\cite{genomes} to perform a search of the NCBI data base for the chromosomal genome of our animals of interest. Vectors containing the Latin names, Common names, and ID numbers of our species were created, used to create a data frame. The information was then passed through a 'for loop' to perform the genome search for each ID number, returning the mitochondrial genome attached to the study in question. Once obtained, we determined the location of the COX1 gene within the genome, and wrote that section to a FASTA file along with a properly formatted Latin name ID. We also pass a command to search for and delete pre-existing FASTA files associated with this study, because repeated compiling efforts would results in duplicate entries being written to the FASTA. 
Here we have generated an xTable showing the information for the species we are interested in:
<<xtable4,results='asis',eval=TRUE>>=
suppressPackageStartupMessages(require(xtable)) #dat[rows,coluimns]
table<-Animal_Data
print(xtable(table,
       caption='Species of interest',
       include.rownames=T)) 
@

<<msucle,eval=TRUE,results='hide'>>=
require(muscle)
aln<-muscle(seqs='Fetch.fasta')
system('if [ -e "Fetch_aligned.fasta" ]
then
  echo "Removing existing Fetch_aligned.fasta"
  rm Fetch_aligned.fasta
fi')
write.fasta(aln,'Fetch_aligned.fasta')
@
In this section, we have aligned the sequences with the Muscle\cite{muscle} package. Again, we included a step to delete any previously existing FASTA files associated with the analysis as to prevent entry duplication. 
<<phangorn,eval=TRUE>>=
suppressPackageStartupMessages(require(phangorn))
animals<-read.phyDat('Fetch_aligned.fasta',format='fasta',type='DNA')
DistanceMatrix<-dist.dna(as.DNAbin(animals))
treeUPGMA<-upgma(DistanceMatrix)

pngfile=paste('treeUPGMA','.png', sep='')
  png(file=pngfile,width=800,height=800,res=80)
plot(treeUPGMA,main="COX1 relations (UPGMA);rooted (assumes a common ancestor)")
dev.off()

treeNJ<-NJ(DistanceMatrix)
pngfile=paste('NJtree','.png', sep='')
png(file=pngfile,width=800,height=800,res=80)
plot(treeNJ,main='COX1 relations (unrooted, no common ancestor)',type='unrooted')
dev.off()
@
\begin{figure}
    \centering
    \includegraphics[width=0.8\textwidth]{treeUPGMA}
    \caption{Phylogenetic tree}
    \label{}
\end{figure}
% \begin{figure}
%     \centering
%     \includegraphics[width=0.8\textwidth]{NJtree}
%     \caption{Neighbor-joining tree}
%     \label{}
% \end{figure} %this tree looks really bad & is unneccessary, don't include it
In this section, we have used the Phangorn\cite{phangorn} package to create an UPGMA phylogenetic tree showing the evolutionary relationships between these species. The tree shows that the manatee and hyrax are the least related to the rest of the group; this makes sense, as these were chosen to be out groups. The mastodon is the least related to the other, though I was surprised to see that it was less related to the mammoths than the modern day elephants. We also created a Neighbor-joining tree. These plots were made by writing the trees to PNG files which were embedded in the document to give better display formatting.

Now we will improve our phylogenetic tree using the Maximum Likelihood parameters
Continuing in Phangorn\cite{phangorn}.
<<maxLike,eval=TRUE>>=
fitNJ<-pml(treeNJ,data=animals) 
fitNJ<-optim.pml(fitNJ,optNni=T)
bsNJ<-bootstrap.pml(fitNJ,bs=100,optNni=T,control=pml.control(trace=0))
  pngfile=paste('BootStrapTree','.png', sep='')
  png(file=pngfile,width=800,height=800,res=80)
  plotBS(fitNJ$tree,BStrees=bsNJ,type='cladogram',main='Relations of species based on COX1 gene (Maximum Likelihood)')
  dev.off()
@
\begin{figure}
    \centering
    \includegraphics[width=0.8\textwidth]{BootStrapTree}
    \caption{Phylogenetic tree with bootstrap data}
    \label{}
\end{figure}

In this section, we have created a neighbor joining tree with bootstrap data included. Bootstrap data shows how confident we can be of the validity of the tree's branches. This plot shows that we can be very confident that our branches are correctly plotted, except for the branch leading to the mammoths. This branch has an extremely low confidence value, meaning that it is likely that this is incorrect. Including more samples in the tree could help clear up this area, or examining another conserved gene. 

\bibliography{references}
\bibliographystyle{NAR}


\section{System and Session Information}
<<Session>>=
system('uname -srv',intern=T)
sessionInfo()
@
\end{document}
